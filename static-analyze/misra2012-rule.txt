Appendix A Summary of guidelines
Dir 1.1
Required
JP:プログラムの出力が依存する処理系定義の動作は、文書化され、理解されなければならない
Dir 2.1
Required
JP:すべてのソースファイルは、コンパイルエラーなしでコンパイルしなければならない
Dir 3.1
Required
JP:すべてのコードは文書化された要件へ追跡可能でなければならない
Dir 4.1
Required
JP:実行時の障害は最小限に抑えられなければならない?(補足)
Dir 4.2
Advisory
JP:アセンブリ言語のすべての使用は文書化されなければならない
Dir 4.3
Required
JP:アセンブリ言語は、カプセル化され、隔離されなければならない
Dir 4.4
Advisory
JP:コードの一部を「コメントアウト」してはならない
Dir 4.5
Advisory
JP:可視性が重複して、同じ名前空間にある識別子は、表記上明白でなければならない?(補足)
Dir 4.6
Advisory
JP:基本的な数値型の代わりに、サイズと符号の有無を示すtypedefを使用しなければならない
Dir 4.7
Required
JP:関数がエラー情報を返す場合は、そのエラー情報を判定しなければならない
Dir 4.8
Advisory
JP:構造体や共用体へのポインタが翻訳単位内で逆参照されることがない場合、オブジェクトの実装は隠されなければならない
Dir 4.9
Advisory
JP:関数形式マクロの代わりに、互換性のある関数を使用しなければならない
Dir 4.1
Required
JP:ヘッダファイルの内容が複数回インクルードされないように注意しなければならない
Dir 4.11
Required
JP:ライブラリ関数に渡す値の妥当性を確認しなければならない
Dir 4.12
Required
JP:動的なメモリ割り当てを使用してはならない
Dir 4.13
Advisory
JP:リソースに対する操作を提供するように設計された関数は、適切な順序で呼び出さなければならない?(補足)
Rule 1.1
Required
JP:プログラムは標準Cの構文と制約の違反が含まれていないものとし、処理系の翻訳限界を超えてはならない
Rule 1.2
Advisory
JP:言語拡張を使用してはいけない?(補足)
Rule 1.3
Required
JP:未定義の動作またはクリティカルな未規定の動作の発生があってはならない?(補足)
Rule 2.1
Required
JP:プロジェクトは到達不能なコードを含んではならない
Rule 2.2
Required
JP:デッドコードがあってはならない
Rule 2.3
Advisory
JP:プロジェクトは未使用の型宣言を含んではならない
Rule 2.4
Advisory
JP:プロジェクトは未使用のタグ宣言を含んではならない
Rule 2.5
Advisory
JP:プロジェクトは未使用のマクロ宣言を含んではならない
Rule 2.6
Advisory
JP:プロジェクトは未使用のラベル宣言を含んではならない
Rule 2.7
Advisory
JP:関数内に未使用のパラメータがあってはならない
Rule 3.1
Required
JP:「/*」や「//」という文字の並びをコメント内で使用してはならない
Rule 3.2
Required
JP:ラインスプライシングは//コメントで使用してはならない?(補足)
Rule 4.1
Required
JP:8進と16進の逆斜線表記は終了させなければならない
Rule 4.2
Advisory
JP:3文字表記を使用してはならない
Rule 5.1
Required
JP:外部識別子は異なったものにしなければならない
Rule 5.2
Required
JP:同じスコープと名前空間で宣言された識別子は異なったものにしなければならない
Rule 5.3
Required
JP:内側のスコープで宣言された識別子は、外側のスコープで宣言された識別子を隠してはならない
Rule 5.4
Required
JP:マクロ識別子は異なったものにしなければならない
Rule 5.5
Required
JP:識別子はマクロ名とは異なったものにしなければならない
Rule 5.6
Required
JP:typedef名は一意の識別子でなければならない
Rule 5.7
Required
JP:tag名は一意の識別子でなければならない
Rule 5.8
Required
JP:外部リンケージを持つオブジェクトや関数を定義する識別子は一意でなければならない
Rule 5.9
Advisory
JP:内部リンケージを持つオブジェクトや関数を定義する識別子が一意でなければならない
Rule 6.1
Required
JP:ビットフィールドは適切な型で宣言されなければならない?(補足)
Rule 6.2
Required
JP:ビットフィールドで名付けられたシングルビットは符号付きの型であってはならない?(補足)
Rule 7.1
Required
JP:8進定数を使用してはならない
Rule 7.2
Required
JP:符号なしの型で表現されているすべての整数定数には「u」または「U」接尾語を適用しなければならない
Rule 7.3
Required
JP:小文字の "l"はリテラルの接尾語に使用してはならない
Rule 7.4
Required
JP:オブジェクトの型が「const修飾文字へのポインタ」でない限り、文字列リテラルをオブジェクトに代入してはならない
Rule 8.1
Required
JP:型は明示的に指定されなければならない
Rule 8.2
Required
JP:関数型は名前付きパラメータを持つプロトタイプの形式でなければならない
Rule 8.3
Required
JP:オブジェクトまたは関数のすべての宣言は、同じ名前と型修飾子を使用しなければならない
Rule 8.4
Required
JP:外部リンケージを持つオブジェクトや関数が定義される場合、その適合する宣言は可視でなければならない
Rule 8.5
Required
JP:外部オブジェクトまたは関数は1つだけの生存で一度だけ宣言されなければならない
Rule 8.6
Required
JP:外部リンケージを持つ識別子は、1つの外部定義を持たなければならない
Rule 8.7
Advisory
JP:翻訳単位内での参照がただ1つである場合、関数やオブジェクトは外部リンケージを使用して定義してはいけない
Rule 8.8
Required
JP:静的記憶クラス指定子は、内部リンケージを持つオブジェクトおよび関数のすべての宣言で使用されなければならない
Rule 8.9
Advisory
JP:識別子が単一の関数内にのみ出現する場合、そのオブジェクトはブロックスコープで定義されなければならない
Rule 8.1
Required
JP:インライン関数は、静的記憶域クラスを使用して宣言されなければならない?(補足)
Rule 8.11
Advisory
JP:外部リンケージを持つ配列を宣言する場合、その大きさは明示的に指定されなければならない
Rule 8.12
Required
JP:列挙子リスト内では、暗黙的に指定された列挙定数の値は一意でなければならない
Rule 8.13
Advisory
JP:ポインタは可能な限りconst修飾型を指さなければならない
Rule 8.14
Required
JP:restrict型修飾子を使用してはならない?(補足)
Rule 9.1
Mandatory
JP:自動記憶域期間を持つオブジェクトの値を値が設定される前に読んではいけない
Rule 9.2
Required
JP:集成体または共用体の初期化子は波括弧で囲まれなければならない
Rule 9.3
Required
JP:配列は部分的に初期化してはならない
Rule 9.4
Required
JP:オブジェクトの要素は複数回初期化されてはならない
Rule 9.5
Required
JP:指定された初期化子が配列オブジェクトの初期化に使用されている場合、配列のサイズは明示的に指定されなければならない
Rule 10.1
Required
JP:オペランドが不適切な実質的な型であってはならない
Rule 10.2
Required
JP:実質的に文字型の式は、加算と減算操作で不適切に使用してはならない
Rule 10.3
Required
JP:式の値はより狭い実質的な型または異なる実質的な型分類でオブジェクトに代入してはならない
Rule 10.4
Required
JP:通常の算術変換が実行される演算子の両方のオペランドは同じ実質的な型分類を持たなければならない
Rule 10.5
Advisory
JP:式の値は不適切な実質的な型にキャストしてはならない
Rule 10.6
Required
JP:複合式の値を、より広い実質的な型のオブジェクトに代入してはならない
Rule 10.7
Required
JP:複合式が通常の算術変換が実行される演算子の1つのオペランドとして使用されている場合、もう一方のオペランドは、より広い実質的な型を持ってはいけない
Rule 10.8
Required
JP:複合式の値は異なる実質的な型分類やより広い実質的な型にキャストしてはならない
Rule 11.1
Required
JP:変換は関数へのポインタと任意の他の型との間で行われてはならない
Rule 11.2
Required
JP:変換は不完全な型へのポインタと任意の他の型との間で行われてはならない
Rule 11.3
Required
JP:キャストはオブジェクト型へのポインタ型と別のオブジェクト型へのポインタとの間で行われてはならない
Rule 11.4
Advisory
JP:変換はオブジェクトへのポインタと整数型との間で行われてはいけない
Rule 11.5
Advisory
JP:変換はvoidへのポインタからオブジェクトへのポインタに行われてはいけない
Rule 11.6
Required
JP:キャストはvoidへのポインタと算術型との間で行われてはならない
Rule 11.7
Required
JP:キャストはオブジェクトへのポインタと非整数算術型との間で行われてはならない
Rule 11.8
Required
JP:キャストはポインタによって指さされた型から任意のconstまたはvolatile修飾を削除してはならない
Rule 11.9
Required
JP:マクロNULLは整数ヌルポインタ定数の形式のみ許されなければならない
Rule 12.1
Advisory
JP:式の中の演算子の優先順位は明白でなければならない
Rule 12.2
Required
JP:シフト演算子の右側のオペランドは、0以上で、左側のオペランドの実質的な型のビット幅未満でなければならない
Rule 12.3
Advisory
JP:コンマ演算子を使用してはならない
Rule 12.4
Advisory
JP:定数式の評価は、符号なし整数のラップアラウンドを引き起こしてはならない
Rule 13.1
Required
JP:初期化リストは永続的な副作用を含んではならない?(補足)
Rule 13.2
Required
JP:式の値とその永続的な副作用は、すべての許可された評価順で同じでなければならない
Rule 13.3
Advisory
JP:インクリメントまたはデクリメント演算子を含む完全な式はインクリメントまたはデクリメント演算子に起因するもの以外、他の潜在的な副作用があってはならない
Rule 13.4
Advisory
JP:代入演算子の結果を使用してはならない
Rule 13.5
Required
JP:&&や||の論理演算子の右側のオペランドは、永続的な副作用を含んではならない
Rule 13.6
Mandatory
JP:sizeof演算子のオペランドは潜在的な副作用を持っている任意の式を含んではならない
Rule 14.1
Required
JP:ループカウンタは、実質的に浮動小数点型を持ってはいけない
Rule 14.2
Required
JP:forループは適正に定義されなければならない
Rule 14.3
Required
JP:制御式は不変であってはならない
Rule 14.4
Required
JP:if文の制御式と繰り返し文の制御式は、実質的にBoolean型を持たなければならない
Rule 15.1
Advisory
JP:goto文を使用してはならない
Rule 15.2
Required
JP:goto文は、同じ関数のより後ろで宣言されたラベルにジャンプしなければならない
Rule 15.3
Required
JP:goto文によって参照されるラベルは、同じブロック内、またはgoto文を囲む任意のブロック内で宣言されなければならない
Rule 15.4
Advisory
JP:繰り返し文を終了するために使用されるブレーク文またはgoto文は1個以下でなければならない
Rule 15.5
Advisory
JP:関数は、その最後に1つだけの出口を持たなけらばならない
Rule 15.6
Required
JP:反復文や選択文の本体は、複合文でなければならない
Rule 15.7
Required
JP:すべてのif ... else if構文は、else文で終了しなければならない
Rule 16.1
Required
JP:すべてのswitch文は適正に定義されなければならない
Rule 16.2
Required
JP:スイッチのラベルは、それを直接内包している複合文がswitch文の本体である場合にのみ使用されなければならない
Rule 16.3
Required
JP:無条件のbreak文で、すべてのスイッチ節を終了しなければならない
Rule 16.4
Required
JP:すべてのswitch文は、デフォルトのラベルをもたなければならない
Rule 16.5
Required
JP:デフォルトのラベルは、switch文の最初または最後いずれかのスイッチのラベルとしなければならない
Rule 16.6
Required
JP:すべてのswitch文は、少なくとも2つのスイッチ節を持たなければならない
Rule 16.7
Required
JP:スイッチ式は実質的にブール型を持ってはいけない
Rule 17.1
Required
JP:<stdarg.h>の特色を使用してはならない?(補足)
Rule 17.2
Required
JP:関数は、直接的または間接的に、自分自身を呼び出しはいけない
Rule 17.3
Mandatory
JP:関数を暗黙的に宣言してはならない
Rule 17.4
Mandatory
JP:void以外の戻り値の型を持つ関数からのすべての出口は式を伴った明示的なreturn文を持たなければならない
Rule 17.5
Advisory
JP:配列型を持つように宣言されたパラメータに対応する関数の引数は、要素の適切な数を持たなければならない
Rule 17.6
Mandatory
JP:配列パラメータの宣言は、[ ]の間に静的キーワードを含んではならない?(補足)
Rule 17.7
Required
JP:void以外の戻り値の型を持つ関数が返す値は使用されなければならない
Rule 17.8
Advisory
JP:関数パラメータを変更してはいけない
Rule 18.1
Required
JP:ポインタオペランドの算術に起因するポインタはそのポインタのオペランドと同じ配列の要素を処理しなければならない
Rule 18.2
Required
JP:ポインタ間の減算は、同じ配列の要素を扱うポインタにのみ適用されなければならない
Rule 18.3
Required
JP:関係演算子>、>=、<と<=は、それらが同じオブジェクト内を指している場合を除いて、ポインタ型のオブジェクトに適用してはならない
Rule 18.4
Advisory
JP:+、 - 、+=と - =演算子は、ポインタ型の式に適用してはいけない
Rule 18.5
Advisory
JP:2段階を超える入れ子のポインタを宣言してはいけない
Rule 18.6
Required
JP:自動記憶域を持つオブジェクトのアドレスを、そのオブジェクトが存在しなくなった後も存在する別のオブジェクトにコピーしてはならない
Rule 18.7
Required
JP:フレキシブル配列メンバを宣言してはいけない
Rule 18.8
Required
JP:可変長配列型を使用してはならない
Rule 19.1
Mandatory
JP:オブジェクトは、重複オブジェクトに代入あるいはコピーされてはならない?(補足)
Rule 19.2
Advisory
JP:unionキーワードを使用してはならない
Rule 20.1
Advisory
JP:#include指令に対しては、他の前処理指令やコメントのみが先行しうる
Rule 20.2
Required
JP:「'」、「"」または「\」文字、「/*」または「//」文字列がヘッダファイル名に存在してはならない
Rule 20.3
Required
JP:#include指令の後には<filename>文字列または"filename"文字列のどちらかが続かなくてはならない
Rule 20.4
Required
JP:マクロは、キーワードと同じ名前で定義してはいけない
Rule 20.5
Advisory
JP:#undefを使用してはならない
Rule 20.6
Required
JP:前処理指令のように見える字句は、マクロ引数内に存在してはならない
Rule 20.7
Required
JP:マクロパラメータの展開の結果生じる式は、括弧で囲まれなければならない
Rule 20.8
Required
JP:#if前処理指令または#elif前処理指令の制御式は、0または1に評価されなければならない
Rule 20.9
Required
JP:#if前処理指令または#elif前処理指令の制御式で使用されるすべての識別子は、評価の前に#defineされていなければならない
Rule 20.1
Advisory
JP:#前処理演算子と##前処理演算子を使用してはならない
Rule 20.11
Required
JP:#演算子の直後に続くマクロパラメータの直後に##演算子を続けてはいけない
Rule 20.12
Required
JP:さらに先のマクロ置換の変換そのものである、#演算子または##演算子のオペランドとして使用されるマクロパラメータは、これらの演算子のオペランドとして使用されなければならない
Rule 20.13
Required
JP:その最初の字句が#である行は、有効な前処理指令でなければならない
Rule 20.14
Required
JP:すべての#else、#elif と#endif 前処理指令は、関連する#if、#ifdef、または#ifndef指令と同じファイルになければならない
Rule 21.1
Required
JP:予約済み識別子や予約済みマクロ名に対して#defineや#undefを使用してはならない
Rule 21.2
Required
JP:予約済み識別子またはマクロ名を宣言してはならない
Rule 21.3
Required
JP:<stdlib.h>のメモリ割り当てと解放の機能を使用してはならない
Rule 21.4
Required
JP:標準ヘッダファイル<setjmp.h>を使用してはならない
Rule 21.5
Required
JP:標準ヘッダファイル<signal.h>を使用してはならない
Rule 21.6
Required
JP:標準ライブラリの入力/出力の機能を使用してはならない
Rule 21.7
Required
JP:<stdlib.h>のatof関数、atoi関数、atol関数とatoll関数を使用してはならない
Rule 21.8
Required
JP:<stdlib.h>のライブラリ関数 abort、exit、getenv そしてsystemを使用してはならない
Rule 21.9
Required
JP:<stdlib.h>のライブラリ関数 bsearchとqsortを使用してはならない?(補足)
Rule 21.1
Required
JP:標準ライブラリのtimeとdate関数を使用してはいけない?(補足)
Rule 21.11
Required
JP:標準ヘッダファイル<tgmath.h>を使用してはならない?(補足)
Rule 21.12
Advisory
JP:<fenv.h>の例外処理機能を使用してはいけない
Rule 22.1
Required
JP:標準ライブラリ関数を用いて動的に得られたすべてのリソースは、明示的に解放されなければならない
Rule 22.2
Mandatory
JP:メモリブロックは、それが標準ライブラリ関数を用いて割り当てられていた場合にのみ、解放されなければならない
Rule 22.3
Required
JP:同じファイルを、同時に異なるストリームで、読取りアクセスと書込みアクセスのためにオープンしてはいけない
Rule 22.4
Mandatory
JP:読み取り専用として開かれたストリームに書き込もうとしてはいけない
Rule 22.5
Mandatory
JP:FILEオブジェクトへのポインタを逆参照してはならない
Rule 22.6
Mandatory
JP:関連したストリームが閉じられた後に、FILEへのポインタの値を使用してはならない

